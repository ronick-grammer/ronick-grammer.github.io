---
title:  "[OS] 디스크 관리"
excerpt: "[OS] 디스크 관리"
toc: true
toc_sticky: true

header:
  teaser: /assets/images/bio-photo-keyboard-teaser.jpg

categories:
  - OS
<!-- tags:
  - Database 
last_modified_at: 2021-01-04 -->
---
# 디스크 관리
- 디스크(disc)는 컴퓨터 시스템의 대표적인 2차 저장장치이다. 컴퓨터에서 수행한 작업의 결과를 영구히 보관하기 위해서는 디스크와 같은 2차 저장장치를 이용해야 한다.

## 1.디스크의 구조
- 논리블록(logical block) : 디스크에서 일정한 크기의 저장공간이다. 디스크에 데이터가 저장될 때에는 논리블록 단위로 저장되고, 디스크 외부로 입출력이 일어날 때에도 논리블록 단위로 전송된다.
  논리블록에 저장된 데이터에 접근하기 위해 인덱스 번호를 디스크에 전달하여 디스크 컨트롤러가 해당 논리블록이 저장된 물리적 위치를 찾아 요청된 데이터에 대한 작업을 수행한다.

- 섹터(sector) : 각 논리블록이 저장되는 디스크 내의 물리적인 위치이다. 즉, 논리블록 하나가 섹터 하나와 1 대 1로 매핑되어 저장된다. 섹터에는 최소한의 단위 정보가 저장된다.

- 마그네틱 원판 : 하나의 디스크 내에 원판의 수는 하나일 수도 있고 여러 개일 수도 있다.

- 트랙(track) : 섹터로 구성된 하나의 집합이다.(링 모양)

- 실린더(cylinder) : 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집합이다. 섹터 0은 최외각 실린더의 첫번째 트랙에 있는 첫 번째 섹터이다.

- 헤드(head) : 디스크의 섹터에 데이터를 읽고 쓰는 역할을 한다.

- 암(arm) : 헤드를 섹터가 위치한 실린더까지 이동시켜주는 역할을한다. 암과 헤드는 붙어있다.

## 2. 디스크 스케줄링(disk scheduling)
- 디스크에 대한 접근시간(access time)은 탐색시간, 회전지연시간, 전송시간으로 구분된다.
  - 탐색시간(seek time) : 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간이다.
  - 회전지연시간(rotational latency) : 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도닥하기까지 걸리는 시간이다.
  - 전송시간(transfer time) : 해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간이다.

- 회전 지연시간과 전송시간은 상대적인 수치가 작고 운영체제가 통제하기 힘든 부분이기 때문에 탐색시간을 줄여서 최소화하는 스케줄링 작업을 한다.

- 디스크 스케줄링이란 효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떠한 순서로 처리할 것인지 결정하는 메커니즘이다.
- 가장 중요한 목표는 디스크 헤드의 이동거리를 줄이는 것이다.

1) FCFS(First Come First Served) 스케줄링
   - 디스크에 먼저 들어온 요청을 먼저 처리하는 방식이다.
   - 최악의 경우 입출력 요청이 디스크의 한쪽 끝과 반대쪽 끝에 번갈아 도착한다면 헤드는 디스크를 계속 왕복하며 일을 처리해야 하므로 탐색 시간이 매우 비효율적으로 늘어난다. 

2) SSTF 스케줄링
   - 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 방식이다.
   - 헤드의 이동거리를 줄여 디스크 입출력의 효율성을 증가시키지만, 자칫 기아 현상(starvation)을 발생시킬 수 있다.
   - 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생할 수 있다.

3) SCAN 알고리즘
   - 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리한다. 즉 디스크의 어떠한 위치에 요청이 들어오는가와 상관없이 헤드는 정해진 방향으로 이동하면서 길목에 있는
     요청들을 처리하며 지나간다.
     
   - 한 방향으로 이동하여 디스크의 한쪽 끝에 도달하면 방향을 바꾸어 다른 쪽 끝을 향해 이동하면서 그 경로에 있는 모든 요청을 처리한다.
   
   - 엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm) 이라고도 부른다.
   - FCFS처럼 불필요한 헤드의 이동이 발생하거나 SSTF처럼 일부 지역이 지나치게 오래 기다리는 현상이 발생하지 않으며 효율성과 형평성을 모두 만족하는 방식이다.
   - 한쪽 끝에서 다른 쪽 끝으로 한 번만 이동하면 현재 큐에 들어온 모든 요청을 처리할 수 있으므로 이동 거리 측면에서 매우 효율적이다.
   - 헤드가 전체 실린더를 한 번 스캔하는 시간이면 기다리던 모든 요청이 처리되므로 일부 요청이 지나치게 오래 기다리는 현상도 발생하지 않는다.
   - 하지만 제일 안쪽이나 제일 바깥쪽 위치보다는 가운데 위치가 기다리는 평균시간이 더 짧다. 
     - 예) 가장 끝 위치 실린더를 지나가고 나서 그 끝 위치 실린더 지점에 요청이 들어오면 반대로 갔다가 다시 돌아와야 한다.

4) C-SCAN (Circular-SCAN) 알고리즘
   - SCAN 알고리즘과 비슷하나 헤드가 다른 쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 다시 이동만 한다.
   - 각 실린더 위치에 대해 SCAN보다 좀 더 균일한 탐색시간을 제공한다.
   - SCAN보다 헤드의 이동거리는 조금 길어지지만 탐색시간의 편차를 줄일 수 있다는 것이 C-SCAN의 장점이라 할 수 있다.

5) LOOK 알고리즘
   - 헤드가 한쪽 방향으로 이동하다가 그 방향에 더 이상 대기 중인 요청이 없으면 헤드의 이동 방향을 즉시 반대로 바꾸는 스케줄링 방식이다. 
   - 즉 방향의 끝 실린더까지 가는 것이 아니라 요청이 존재하는 방향의 마지막 실린더 번호까지만 이동하고 방향을 반대로 바꾼다. 
   - 헤드가 진행하는 방향에 요청이 있는지를 살핀 후 이동하기 때문에 LOOK 이라고 부른다.

6) C-LOOK 알고리즘
   - 전방에 요청이 없을 때 방향을 바꾼다는 측면에서 LOOK과 유사하며, 한쪽 방향으로 이동할 때에만 요청을 처리한다는 점에서 C-SCAN과 유사하다.


* SCAN, S-SCAN 및 이들을 좀 더 개선한 LOOK, C-LOOK 등의 스케줄링 알고리즘이 디스크 입출력이 많은 시스템에서 FCFS나 SSTF에 비해 더 효율적인 것으로 알려져 있다.

## 3. 다중 디스크 환경에서의 스케줄링
- 같은 데이터가 저장되어 있는 여러 개의 디스크 중 어느 디스크에서 요청을 처리할지 결정하는 스케줄링 문제가 발생한다.
- 다중 디스크에서의 스케줄링은 입출력 요청의 처리 순서 결정뿐만 아니라 작업을 수행할 디스크를 결정하는 문제까지 포함한다.
- 탐색시간을 줄이는 것이 목표라면 여러 디스크 중에서 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크를 선택하는 방법을 사용할 수 있다.
- 많은 요청을 동시에 처리할 수 있는 확장성 있는 서비스가 목표이므로 일부 디스크가 과부하 상태에 이르지 않고 모든 디스크에 요청이 골고루 분배되도록 스케줄링해야한다.
- 전력 소모를 줄이는 것이 디스크 관리의 중요한 목표로 인식되고 있다. 일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시키는 것이 효과적이다. 요청이 빈번하지 않은 상황에 한해서 성립한다.

## 4. 디스크의 저전력 관리
1) 비활성화 기법
   - 디스크의 상태는 전력 소모를 기준으로 크게 네 가지 상태로 나눌 수 있다.
     - 활동(active) 상태 : 현재 헤드가 데이터를 읽거나 쓰고 있는 상태
     - 공회전(idle) 상태 : 디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태
     - 준비(ready) 상태 : 디스크가 회전하지 않지만 인터페이스가 활성화된 상태
     - 휴면(sleep) 상태 : 디스크가 회전하지 않고 인터페이스도 비활성화된 상태

   - 요청이 없을 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효과적이다.
   - 비활성 상태에서 데이터를 읽고 쓰려면 활성 상태일 때보다 부가적인 전력 소모가 뒤따른다.
   - 후속 요청까지의 시간 간격이 일정 시간(breank-even time) 이상일 경우에만 디스크의 회전을 정지시키는 것이 전력 소모를 절감하는데 효과적이다.

   - 디스크를 비활성화하는 시점을 결정하는 방법으로는 세가지가 있다.
     - 시간 기반(timeout based) : 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지시켰다가, 다시 요청이 들어 왔을 때 디스크를 활성화한다.
     - 예측 기반(prediction baesd) : 과거 요청을 관찰하여 다음 공회전 구간의 길이를 예측한 후 디스크를 비활성화할 시점을 결정한다.
     - 확률기반(stochastic based) : 디바이스의 상태변경 시간 간격을 구하기 위해 확률분포를 통해 요청을 모델링하고 마르코프 체인(Markov chain)등과 같은 통계적 모델을 이용한다.

2) 회전속도 조절 기법
   - 디스크의 회전 속도(Rotations Per Minute: RPM)를 가변적으로 조절하는 기법이다.
   - 운영체제는 시스템 자원과 부하를 포괄적으로 볼 수 있기 때문에 하드웨어 혼자서 전력관리를 하는 것에 비해 더 많은 전력 절감 효과를 얻을 수 있다.
   - 멀티 미디어 환경에서는 시간에 따른 순차적인 데이터 접근이 이루어지므로 주기성과 규칙성이 있어 미래의 참조에 대한 예측이 비교적 정확하게 이루어질 수 있다.
   - 전력 소모를 최소화하기 위해 실시간 응용프로그램의 재생률(bit rate)과 버퍼 크기에 따라 디스크의 회전속도를 조절해서 전력 소모를 최소화하는 기법도 제안되었다.

3) 디스크의 데이터 배치 기법
   - 대부분의 컴퓨터 시스템에서 디스크의 53% 이상이 빈 공간인 상태로 남아 있다는 점에 착안해, 디스크 내에 데이터의 복제본(replica)을 많이 만들어 헤드 위치에서 가까운 복제본에 접근하도록 함으로써 빠른
     응답시간과 전력 소모량 절감을 얻는 FS2 파일 시스템(free space file system)이 제안되었다.
   
   - 복제본이 있는 경우 쓰기 연산에서 일관성(consistency)문제가 발생할 수 있으나, FS2에서는 헤드의 위치에서 가까운 복제본에 데이터를 쓰고 나머지 복제본들에 대해서는 주소 테이블에 무효화(invalication)
     연산만을 수행해 쓰기연산의 효율성을 높인다.

4) 버퍼캐싱 및 사전인출 기법
   - 요청될 데이터를 미리 어느 정도 예측할 수 있다면 디스크가 활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전인출(prefetching)함으로써 향후 디스크의 비활성화 가능성을 높여 전력 소모를 줄일 수 있다.
   - 긴급한 요청이 아닐 경우 디스크의 활성 상태 여부에 따라 요청을 최대한 지연시키는 방식으로 전력 소모를 줄일 수 있다.
   - 디스크가 저전력 모드일 때는 입출력 처리를 최대한 지연시켰다가 디스크가 정상 전력 모드로 돌아왔을 때 사전인출을 함으로써 디스크의 상태 변화 횟수를 최소화하는 방법이 연구되었다.

5) 쓰기전략을 통한 저전력 디스크 기법
   - 대상 디스크가 비활성 상태을 때에는 디스크 쓰기를 하지 않고 기다렸다가, 디스크가 활성 상태로 돌아왔을 때 쓰는 방식(wirte-back with eager updates)으로 전력 소모를 줄이는 방안이 연구되었다.
   - 대상 디스크가 활성 상태가 아니면 일단 블록들을 로그 디스크에 썼다가 디스크가 활성 상태로 돌아왔을 때 디스크에 쓰기연산을 수행하는 방식이 제안되었다.
