---
title:  "[OS] 프로세스 관리"
excerpt: "[OS] 프로세스 관리"
toc: true
toc_sticky: true

header:
  teaser: /assets/images/bio-photo-keyboard-teaser.jpg

categories:
  - OS
<!-- tags:
  - Database 
last_modified_at: 2021-01-04 -->
---
# 프로세스 관리

## 1. 프로세스의 개념

- '프로세스(process)'란 실행 중인 프로그램(program in execution)을 뜻한다. 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 비로소 생명력을 갖는 프로세스가 되며,
프로세스는 CPU를 휙득해 자신의 코드를 수행하기도 하고, 때로는 CPU를 반환하고(운영체제에게) 입출력 작업을 수행하기도 한다.

- '프로세스의 문맥'이란 프로세스가 현재 어떤 상태에서 실행되고 있는지 규명하기 위해 필요한 정보를 의미한다. 타이머 인터럽트에 의해 짧은 시간 CPU를 빼앗겼다가 다시 휙득해 명령의 수행을 재개하는 
  시점이 되면 이전의 CPU 보유 시기에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다. 이때 정확한 재현을 위해 필요한 정보가 프로세스의 문맥이다. 
  
- 프로세스의 문맥을 크게 세 가지로 분류할 수 있다.
  - 하드웨어 문맥 : CPU의 수행 상태를 나타내는 것으로 프로그램 카운터 값과 각종 레지스터에 저장하고 있는 값들을 의미한다.
  - 프로세스 주소 공간 : 프로세스는 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.
  - 커널상의 문맥 : 프로그램이 수행되어 프로세스가 되면 운영체제는 프로세스를 관리하기 위한 자료구조를 유지한다. PCB와 커널 스택이 이에 해당한다.

## 2. 프로세스의 상태
프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세가지로 구분된다.

- 실행 상태 : 실행 상태는 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태를 가리킨다.
- 준비 상태 : 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만, CPU를 할당받지 못한 상태를 가리킨다.
- 봉쇄 상태 : 프로세스 본인이 요청한 입출력 작업같은 오래 걸리는 작업을 진행 중인 경우에 대기하는 상태를 가리킨다.

이 밖에 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 휙득을 승인받지 못한 '시작 상태'와 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 아직 정리하지 못한 상태인 '완료 상태'가 있다.


- 프로세스가 타이머 인터럽트나 입출력 요청으로 인해 봉쇄 상태로 바뀌는 경우, 다음에 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 '문맥교환(context switch)'라고 한다.

- 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후, 실제로 CPU의 할당권을 넘겨받는 과정을 'CPU 디스패치(dispatch)'라고 한다.

- 입출력 요청으로 봉쇄상태에 있게된 프로세스는 입출력 큐에 줄 서 있다가 자기 차례가 되어 컨트롤러로부터 서비스를 받고 나면 컨트롤러는 CPU에게 인터럽트로 이를 알린다. CPU는 어떤 프로세스를 실행하다가 인터럽트가 
  발생한 것을 보고 인터럽트 처리 루틴으로 이동하는데 이때 실행중이던 프로세스의 상태는 사용자모드 상태에서 커널 모드 상태로 변한다. 이 인터럽트 처리루틴이 직전에 수행되던 프로세스와의 업무와는 연관성이 없긴 하지만
  그럼에도 직전 프로세스가 업무를 수행하다가 인터럽트가 발생해 커널모드로 진입한것으로 본다.


## 3. 프로세스 제어블록
프로세스 제어블록(Process Control Block: PCB)란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다. 다음과 같은 요소로 구성되어 있다.

- 프로세스의 상태(process state) : CPU를 할당해도 되는지 여부를 결정하기 위해 필요하다.
- 프로그램 카운터(program counter) : 다음에 수행할 명령의 위치이다.
- CPU 레지스터(CPU register)의 값 : CPU연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다.
- CPU 스케줄링 정보(CPU scheduling information) : 프로세스의 CPU 스케줄링
- 메모리 관리 정보(memory management information) : 메모리 할당을 위해 필요한 정보
- 자원 사용 정보(accounting information) : 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용된다.
- 입출력 상태 정보(I/O status information) : 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보를 나타낸다.

## 4. 문맥교환
문맥교환(context switch)란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다. 

- 문맥교환 중에 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스의 문맥을 자신의 PCB에 저장하고 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원하는 
  과정을 거친다.
  
- 문맥교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 오버헤드라고 할 수 있다. 따라서 타이머에게 CPU 할당시간을 아주 작게 세팅해 프로세스간 문맥교환이 빈번하게 발생하도록 하면 이에 드는 오버헤드가 커진다.
  반대로, CPU 할당시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색하게 되므로 적절한 CPU 할당시간을 정하는 것이 중요하다.
  
## 5. 프로세스를 스케줄링하기 위한 큐
- 운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(ready queue)를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.

- CPU를 기다리는 프로세스를 줄 세우는 준비 큐 외에도 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐(device queue)를 둔다. 예를 들어 디스크 입출력 서비스를 요청한 프로세스들은 
  디스크 입출력 큐(dist I/O queue)에 줄 서게 된다.

- 여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 공유 데이터를 기다리는 큐에 줄 서게 하여 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 하고, 반납할 경우 
  큐에 줄 서 있는 순서대로 데이터의 접근권한을 준다.

- 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐(queue)를 두어 수행하게 된다. 각 프로세스가 CPU를 기다리는지 등의 정보를 커널이 총체적으로 관리한다는 뜻이다. 예를 들어 타이머 인터럽트가 
  발생하면 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해 다음에 어느 프로세스에게 CPU를 할당할지 결정하고, 현재 실행중인 프로세스는 준비 큐의 제일 뒤로 보낸다.
  
- 작업 큐(job queue)는 시스템 내의 모든 프로세스를 관리하기 위한 큐로, 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업
  큐에 속해 있다.
  
## 6. 스케줄러
스케줄러(scheduler)란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다. 스케줄러에는 '장기 스케줄러'와 '단기 스케줄러'가 있다.

- 장기 스케줄러(long term scheduler) : 장기 스케줄러는 작업 스케줄러(job scheduler)라고도 부르며, 시작상태에 있는 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할을 한다.시작 상태의 프로세스에게 메모리
  할당을 승인할지 여부를 장기스케줄러가 정한다. 과거에 자원이 매우 빈약하던 시절에 주로 사용되었다.

- 단기 스케줄러(short term scheduler) : CPU 스케줄러라고도 하며, 준비 상태의(준비 큐에 있는) 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들어 CPU를 할당할 것인가를 결정한다. 시분할 시스템에서는
  타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.
 
현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 '중기 스케줄러'를 두는 경우가 많다.

- 중기 스케줄러(medium term scheduler) : 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러이다.
  프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화하기 위해 일부 프로세스를 메모리에서 디스크로 스왑아웃시키는 역할을 수행한다.
  

## 7. 프로세스의 생성
시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 이때 프로세스를 생성한 프로세스를 '부모 프로세스' 라고 하고 생성된 
프로세스를 '자식 프로세스'라고 한다.

- 부모 프로세스는 자신이 생성했던 자식 프로세스들이 종료된 후에야 자신도 종료될 수 있다.

- 부모 프로세스와 자식 프로세스는 서로 공존하며 CPU를 휙득하기 위한 경쟁을 하거나 부모 프로세스가 자식 프로세스가 종료될때까지 시스템 콜 wait() 호출을 하여 봉쇄상태에 있다가 자식 프로세스가 종료되면 준비 상태가 되어 CPU를 얻을 권한이 생기게 된다.

- 프로세스가 생성되면 자신만의 독자적인 주소 공간을 가지며, 부모 프로세스가 자식 프로세스를 생성하면 자식 프로세스는 별도의 주소 공간을 가진다. 이때 처음 주소 공간을 생성할 때에는 프로세스 ID를 제외한 모든 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다. 

- 프로세스 종료는 마지막 명령을 수행한 후 운영체제에게 이를 eixt() 시스템 콜로 알려 이루어 지는 '자발적 종료'와 부모 프로세스가 자식 프로세스의 수행을 abort() 시스템 콜로 강제로 종료시키는 것이 있다.

- 운영체제는 자식 프로세스의 생성을 위해 fork() 시스템 콜을 제공하며, 호출을 할 경우 CPU 제어권이 커널로 넘어가서 부모 프로세스의 주소 공간을 비롯해 프로그램 카운터 등 레지스터 상태, PCB 및 커널 스택 등 
  모든 문맥을 그대로 복제해 자식 프로세스의 문맥을 형성하게 된다.

- 원본 프로세스와 복제 프로세스의 차이점은 fork() 함수의 결괏값이 원본에게는 양수를 복제본에게는 0을 주는데에 있다.

- 따라서 새로운 프로그램을 수행하기 위해서는 fork() 시스템 콜을 통해 기존 프로세스와 동일한 프로세스를 복제한 후 exec() 시스템 콜을 통해 새롭게 수행시키려는 프로세스를 자식 프로세스의 주소 공간에 덮어씌우면 된다.

## 8. 프로세스 간의 협력
부모 프로세스와 자식 프로세스는 자원을 서로 휙득하기 위해 경쟁적인 관계에 있게 된다. 경우에 따라서 프로세스들이 협렵할 때 업무의 효율성이 증진될 수 있다. 

- IPC(Inter-Process Communication) : 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신이다. 프로세스들 간의 통신(communication)과 동기화를 이루기 위한 메커니즘을 의미한다.
  두가지 방식이 존재한다.
  
  - 메시지 전달(message passing)방식 : 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식이다. send()화 receive() 라는 두가지 시스템 콜로 메시지를 주고 받을 수 있다.
    직접통신과 간접통신으로 나뉜다.
    
    - 직접통신(direct communication) : 말그대로 통신하려는 프로세스의 이름을 명시적으로 표시하여 서로 커뮤니케이션 링크로 연결되어 직접 통신을 하는 방식이다.
    - 간접통신(indirect communication) : 프로세스들 사이에 메일박스(mail box) 또는 포트(port)가 있으며 이를 두고 간접적으로 통신을 한다.
  
  - 공유메모리(shared memory)방식 : 프로세스들이 주소 공간의 일부를 공유한다. 운영체제는 공유메모리를 사용하는 시스템 콜을 지원해 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록한다.
    공유메모리 방식은 프로세스 간의 통신을 수월하게 만드는 인터페이스를 제공하지만, 서로의 데이터에 일관성 문제가 유발될 수 있다.
    
 
<br><br>
### 참고
- 서적 '운영체제와 정보기술의 원리'
 
    



