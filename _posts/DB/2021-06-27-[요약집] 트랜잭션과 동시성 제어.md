---
title:  "[요약집] 트랜잭션과 동시성 제어"
excerpt: "[요약집] 트랜잭션과 동시성 제어"
toc: true
toc_sticky: true

header:
  teaser: /assets/images/bio-photo-keyboard-teaser.jpg

categories:
  - Database
<!-- tags:
  - Database  -->
---
# 트랜잭션고 동시성 제어

## 트랜잭션
   - 데이터베이스를 사용하는 실제 시스템이나 어플리케이션에서는 단일 쿼리만으로 조작하는 일이 거의 없고 복수의 쿼리 명령어를 연속적으로 사용해 일관성 있는 형태의 한 단위로 취급해야 한다.
   - 이처럼 복수의 쿼리 처리를 하나의 단위로서 '트랜잭션' 이라고 한다.
   - MySQL은 트랜잭션 구조를 사용할 수 있는 InnoDB형 2종류를 이용할 수 있다.
   - 트랜잭션의 4가지 특성 'ACID'
     - 1.Atomicity(원자성) 2.Consistency(일관성) 3.Isolation(고립성 or 격리성) 4.Durability(지속성)
     
     1. Atomicity(원자성) : 데이터의 변경(INSERT/DELETE/UPDATE)을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조이다. 즉, 전부 성공하거나, 아니면 전부 실패하거나 이다.
     2. Consistency(일관성) : 트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것을 '일관성'이라 한다. 데이터 타입이 정수형인 컬럼에 문자열이 저장될 수 없도록 보장하거나 A에서 B로 계좌이체를 할 때
     이 두 계좌의 잔액 총합이 전과 후 모두 같아야 한다는 것을 보장해야한다.
     3. Isolation(고립성 or 격리성) : 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 '각각의 처리가 모순없이 실행되는 것을 보장'한다. 한 트랜잭션이 진행중일때 다른 트랜잭션들은 데이터를 쓸 수 없으며,
     읽기가 가능하지만 격리 수준에 따라 보여지는 데이터가 달라진다.
     4. 지속성(Durability) : 트랜잭션을 완료하고 나서 커밋(commit)을 하고 완료된 시점에서 해당 트랜잭션의 조작이 영구적으로 보존되어 잃지 않는 것을 뜻한다. 이는 예기치 못한 상황으로 OS 이상종료나 기타
     시스템 장애로 인한 데이터 손실 위험이 있을 때도 견딜수 있는 것을 말한다.
     
     <p align = "center">
      <img src = "https://raw.githubusercontent.com/ronick-grammer/ronick-grammer.github.io/main/assets/images/DB/지속성(Durability).JPG" width = "70%">
     </p>
   
   - DDL(Data Definition Language) : 데이터를 저장하는 그릇인 스키마(데이터베이스) 또는 테이블 등을 작성하거나 제거하는 명령어이다. ex) CREATE, DROP 등
   - DML(Data Manipulation Language) : 테이블의 행을 검색하거나 변경하는 데에 사용하는 명령어이다. ex) SELECT, UPDATE 등
   - DCL(Data Control Language) : 데이터베이스에서 실행한 변경을 확정하거나 취소하는 명령어이다. ex) COMMIT, ROLLBACK 등

## 트랜잭션 격리 수준에 따른 외관상 차이
   - MVCC(Multi Versioning Concurrency Control)에 따른 MySQL 특성
     1. 다른 트랜잭션에서 갱신중이어도 읽기를 수행할 경우 블록되지 않는다.
     2. 읽기 내용은 격리수준에 따라 내용이 바뀌는 경우가 있다.
     3. 갱신시 '배타적 잠금'을 얻는다. 잠금은 '행 단위'로 얻으며 트랜잭션이 종료할 때까지 유지한다.
     4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 휙득하려고 할 때 블록되며 일정시간을 기다린다. 그 일정시간을 초과해도 잠금을 휙득하지 못했다면 '잠금 타임아웃'이 된다.
     5. 갱신하는 경우 갱신 전의 데이터를 UNDO 로그로 '롤백 세그먼트'라는 영역에 유지한다. 이는 롤백이나 다른 트랜잭션이 데이터를 읽을때 참도된다.

## 교착 상태
   - 트랜잭션 A와 트랜잭션 B가 잠금을 얻었을 때 서로가 서로의 잠금된 데이터 갱신을 시도하려 할 때 발생하는 상태를 '교착 상태'라 한다.
     
     <p align = "center">
      <img src = "https://raw.githubusercontent.com/ronick-grammer/ronick-grammer.github.io/main/assets/images/DB/교착상태.JPG" width = "70%">
     </p>
     
   - 대책
     1. 트랜잭션을 자주 커밋하여 작은 단위가 되어 가능성을 낮춘다.
     2. 정해진 순서로 테이블(그리고 행)에 액세스하게 한다.
     3. 필요없는 경우에는 읽기 잠금 휙득의 사용을 피한다.
     4. 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다.
     5. 행 단위가 아닌 테이블 단위의 잠금을 휙득하여 갱신을 직렬화 한다.
     6. 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게 된다.
   
## 트랜잭션 처리 주의사항
   - 오토 커밋 : 애플리케이션의 잠금을 실행하는 데는 커밋의 부하가 높다.
   - 긴 트랜잭션 : 트랜잭션의 동시성이나 자원의 유효성을 저하한다. 이는 갱신을 포함한 트랜잭션은 다른 트랜잭션을 블록, 장시간의 경우 타임아웃, 혹은 교착 상태를 일으킬 가능성을 높인다.
   
   예상되는 오류에 대처할 수 있는 형태로 애플리케이션을 작성하기 위해서는 트랜잭션에 대한 오토커밋 설정이나 커밋 읽기의 격리 수준을 기본 값인 '반복 읽기'로 설정하지 않고 시스템 요건이나 애플리케이션의 로직에
   맞추어 설정을 해야한다.








     
  





