---
title:  "[Clean Architecture] 독립성"
excerpt: "[Clean Architecture] 독립성"
toc: true
toc_sticky: true

header:
  teaser: /assets/images/bio-photo-keyboard-teaser.jpg

categories:
  - Architecture & Pattern
---

## 독립성

좋은 아키텍처의 특징

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

- 유스케이스의 경우 시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
- 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아 볼 수 있도록 한다.
- 시스템의 최상위 수준에서 알아볼 수 있으며, 개발자가 일일이 찾아 헤매지 않도록 한다. 이들 요소는 클래스 혹은 함수, 모듈로서 자신의 기능을 분명하게 설명하는 이름을 가진다.

### 운영

- 시스템의 운영 지원 관점에서는 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.
- 아키텍처는 요구와 관련된 각 유스케이스에 걸맞는 처리량과 응답시간을 보장해야 한다.
- 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 기술 스펙트럼 사이를 전환하는 일이 쉬워진다.

### 개발

- 아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.
- 콘웨이 법칙이 작용된다. 
*** 콘웨이 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낸다.**
- 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하여 팀들이 서로를 방해하지 않도록 해야한다.
- 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.

### 배포

- 아키텍처는 배포 용이성을 결정하는데 중요한 역할을 한다.
- ‘즉각적인 배포’를 목표로 한다.
- 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 조금씩 수정하는 방식을 사용하지 않는다.
- 좋은 아키텍처는 꼭 필요한 디렉터리나 파일을 수작업으로 생성하게 하지 않는다.
- 좋은 아키테거는 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
- 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

### 선택사항 열어놓기

- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
- 대부분의 경우 모든 유스케이스를 알 수는 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문에 균형을 잡기가 매우 어렵다.
- 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 많이, 오랫동안 열어 둘 수 있게 해준다.

### 계층 결합 분리

- 아키텍트는 단일 책임 원칙과 공통 패쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고 동일한 이유로 변경되는 것들을 묶는다.
- 유스케이스에서 UI 부분과 업무 규칙 부분을 서로 분리해야 한다. 이렇게 함으로써 두 요소를 서로 독립적으로 변경할 수 있고, 유스케이스는 여전히 가시적이며 분명하게 유지할 수 있다.

### 유스케이스 결합 분리

- 유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.
- UI, 애플리케이션 특화 업무 규칙 그리고 데이터베이스 기능을 분리해야 한다.
    
    예1) **주문 추가 UI** 와 **주문 삭제 UI**를 분리한다.
    
    예2) **주문 추가 업무규칙**과 **주문 삭제 업무규칙**을 분리한다.
    
<img width="70%" alt="1" src="https://user-images.githubusercontent.com/73280175/204082841-8ab1c705-b467-4bcd-a28f-16156c52ff28.PNG">
    
- 이처럼 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있다.

### 개발 독립성

- 컴포넌트가 완전히 분리되면 팀 사이의 간섬은 줄어든다.
- 업무 규칙이 UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 영향을 주지 않는다.

### 배포 독립성

- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다.
- 결합을 제대로 분리했다면 운영 중인 시스템에도 계층과 유스케이스를 교체할 수 있다.

### 중복

- 중복된 코드가 있다면 줄이거나 제거해야 한다. 다만 진짜 중복인지 확인부터 해야 한다.
- **정말로 중복된 코드일 경우**, 한 인스턴스가 변경되면 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.
- **중복된 코드처럼 보이지만 아닐 경우**, 두 코드 영역이 다른 이유로 변경된다면 이 두 코드는 중복 코드가 아니므로 두 코드를 통합하는 일이 없어야 한다.

### 결합 분리 모드

- 유스케이스를 위해 수행되는 결합 부리 작업들은 운영에도 도움이 된다. 운영 측면에서 이점을 살리기 위해서 결합을 분리할때 적절한 모드를 선택해야 한다.
- 분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이라면, 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 함께 상주하는 형태로 만들어져서는 안 된다.
- 분리된 컴포넌트는 반드시 독립된 서비스가 되어야 한다.
- 좋은 아키텍처는 선택권을 열어두기 때문에, 결합 분리 모드는 이러한 선택지 중 하나이다.

**소스 수준  분리모드** 

- 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있다. 이 모드는 **모노리틱 구조**를 사용한다.
    
    ***모노리틱 구조: 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신을 할 때는 간단한 함수 호출을 사용한다. 이로 인해 메모리에서는 하나의 실행 파일만이 로드되는 구조이다.**
    

**배포 수준 분리 모드**

- jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 이를 통해 한 모듈이 변해도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들수 있다.
- 모노리틱 구조를 가진다.
- 결합이 분리된 컴포넌트가 jar 파일, Gem 파일, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할 되어 있다.

**서비스 수준 분리 모드**

- 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.
- 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.

- 프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어렵다.
- 시스템이 한 서버에서 실행되는 동안은 결합은 소스 수준에서 분리하는 것만으로도 충분하지만, 나중에는 배포 가능한 단위, 서비스 수준까지 분리해야 할 수도 있다.

### 결론

- 좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장할 수 있도록 만들어져야 한다.
- 좋은 아키텍처는 상황이 바뀌었을 때, 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다.
- 좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호한다.
- 좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 적합한 모드를 선택한다.
